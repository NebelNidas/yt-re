// **************************
//       Gradle setup
// **************************

buildscript {
	repositories {
		maven {
			name "Fabric Repository"
			url 'https://maven.fabricmc.net'
		}
		maven {
			name "JitPack"
			url 'https://jitpack.io'
		}
		mavenCentral()
		google()
		mavenLocal()
	}
	dependencies {
		classpath "cuchaz:enigma-cli:${project.enigma_version}"
		classpath "commons-io:commons-io:${project.commonsio_version}"
		classpath "net.fabricmc:mapping-io:${project.mappingio_version}"
		classpath "net.fabricmc:tiny-remapper:${project.tiny_remapper_version}"
		classpath "net.fabricmc:name-proposal:${project.name_proposal_version}"
		classpath ("com.github.ThexXTURBOXx.dex2jar:dex-translator:v${project.dex2jar_version}") {
			exclude group: 'com.github.ThexXTURBOXx.dex2jar', module: 'd2j-base-cmd'
		}
	}
}

plugins {
	id 'java' // for constants, packages, javadoc
	id 'maven-publish'
	id 'net.fabricmc.filament' version '0.3.+'
	id 'ytre.plugins.gradle'
	id 'checkstyle'
}

allprojects {
	apply plugin: 'java-library'
	apply plugin: 'checkstyle'

	sourceCompatibility = JavaVersion.VERSION_17
	targetCompatibility = JavaVersion.VERSION_17

	checkstyle {
		configFile = rootProject.file('checkstyle.xml')
	}

	repositories {
		mavenCentral()
		maven {
			name "Fabric Repository"
			url 'https://maven.fabricmc.net'
		}
		google()
		maven {
			name "JitPack"
			url 'https://jitpack.io'
		}
		maven {
			name = 'FlexVer'
			url = 'https://repo.sleeping.town/'
		}
		mavenLocal()
	}
}

configurations {
	asm
	enigmaClasspath {
		extendsFrom asm
	}
	jadxClasspath
	stitchClasspath
	gitifierClasspath
	matcherClasspath
	javadocClasspath
	mappingPoetJar {
		transitive = false
	}
	mappingPoet {
		extendsFrom mappingPoetJar
		extendsFrom asm
		transitive = true
	}
}

dependencies {
	enigmaClasspath "cuchaz:enigma-swing:${project.enigma_version}"
	enigmaClasspath "net.fabricmc:name-proposal:${project.name_proposal_version}"
	enigmaClasspath project(':tools:enigma-plugin')
	jadxClasspath ("com.github.NebelNidas.jadx:jadx-gui:${project.jadx_version}:all") {
		transitive = false
	}
	stitchClasspath "com.github.NebelNidas.stitch:stitch:${project.stitch_version}"
	stitchClasspath project(':tools:stitch-plugin')
	gitifierClasspath project(':tools:gitifier')
	matcherClasspath "com.github.NebelNidas:Matcher:${project.matcher_version}:all"
	javadocClasspath "org.jetbrains:annotations:${project.jetbrains_annotations_version}"
	javadocClasspath "com.google.code.findbugs:jsr305:3.0.2" // for some other jsr annotations
	mappingPoetJar "net.fabricmc:mappingpoet:${project.mappingpoet_version}"
	asm "org.ow2.asm:asm:${project.asm_version}"
	asm "org.ow2.asm:asm-tree:${project.asm_version}"
	asm "org.ow2.asm:asm-commons:${project.asm_version}"
	asm "org.ow2.asm:asm-util:${project.asm_version}"
}

sourceCompatibility = JavaVersion.VERSION_17
targetCompatibility = JavaVersion.VERSION_17

tasks.withType(JavaCompile).configureEach {
	it.options.encoding = "UTF-8"
	it.options.release = 17
}

sourceSets {
	constants
	packageDocs { // package info files
		java.srcDirs = ['packageDocs']
	}

}



// **************************
//        Constants
// **************************

def ENV = System.getenv()
// Fetch build number from Github Actions
def buildNumber = ENV.BUILD_NUMBER ?: "local"

project.ext {
	youtubeVersion = project.youtube_version
	youtubeApkChecksum = project.youtube_apk_md5

	mappingsVersion = "${youtubeVersion}+build.$buildNumber"

	setupGroup = "jar setup"

	mappingsGroup = "yt-mappings"
	buildMappingGroup = "mapping build"
	mappingsDir = file("mappings")
	mapJarGroup = "jar mapping"

	intermediaryDir = file("intermediaries")
	intermediaryCounter = file("${intermediaryDir}/counter.tiny")
	matchesDir = file("matches")
	cacheDir = file(".gradle/youtube")
	tempDir = file(".gradle/temp")
	fakeSourceDir = file(".gradle/temp/fakeSource")
	jadxDir = file('.jadx')
}

version = mappingsVersion



// **************************
//         Classes
// **************************

class FileIO extends DefaultTask {
	@InputFile
	File input
	@OutputFile
	File output
}

class TinyMappingsOutput extends DefaultTask {
	@OutputFile
	File tiny1Output
	@OutputFile
	File tiny2Output
}



// **************************
//        File utils
// **************************

import com.google.common.hash.Hashing
import cuchaz.enigma.command.CheckMappingsCommand
import cuchaz.enigma.command.ConvertMappingsCommand
import groovy.io.FileType
import groovy.json.JsonSlurper
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import net.fabricmc.tinyremapper.TinyUtils

import java.nio.charset.StandardCharsets
import java.util.zip.GZIPOutputStream

boolean isChecksumValid(File file, String checksum) {
	if (file != null) {
		def hash = com.google.common.io.Files.asByteSource(file).hash(Hashing.md5())
		return hash.toString().equals(checksum)
	}
	return false
}


import java.io.File
import java.net.URI;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.LinkOption;
import java.nio.file.NoSuchFileException
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.ZipFile

void deleteDirectory(Path path) throws IOException {
	if (Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS)) {
		try (DirectoryStream<Path> entries = Files.newDirectoryStream(path)) {
			for (Path entry : entries) {
				deleteDirectory(entry);
			}
		}
	}
	Files.delete(path);
}


File removeEntriesFromZip(Path zipFilePath, String... entriesToRemove) {
		/* Define ZIP File System Properies in HashMap */
		Map<String, String> zipProperties = new HashMap<>();
		/* We want to read an existing ZIP File, so we set this to False */
		zipProperties.put("create", "false");

		URI zipFile = URI.create("jar:" + zipFilePath.toUri());

		/* Create ZIP file System */
		try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, zipProperties)) {
			for (String pkg : entriesToRemove) {
				Path pathInZipfile = zipfs.getPath(pkg);
				deleteDirectory(pathInZipfile);
			}
		} catch (NoSuchFileException e) {}
}


void mapJar(File output, File input, File mappings, File libraries, String from, String to,
		Action<TinyRemapper.Builder> action = { }) {
	if (output.exists()) {
		output.delete()
	}

	def remapperBuilder = TinyRemapper.newRemapper()
			.withMappings(TinyUtils.createTinyMappingProvider(mappings.toPath(), from, to))
			.renameInvalidLocals(true)
			.rebuildSourceFilenames(true)
			.invalidLvNamePattern(~/\$\$\d+/)
			.inferNameFromSameLvIndex(true)

	action.execute(remapperBuilder)
	def remapper = remapperBuilder
			.build()

	try {
		def outputConsumerBuilder = new OutputConsumerPath.Builder(output.toPath())
		// expose output consumer builder to function if there is need in the future
		def outputConsumer = outputConsumerBuilder.build()
		outputConsumer.addNonClassFiles(input.toPath())
		remapper.readInputs(input.toPath())

		// libraries.eachFileRecurse(FileType.FILES) { file ->
		// 	remapper.readClassPath(file.toPath())
		// }
		remapper.apply(outputConsumer)
		outputConsumer.close()
		remapper.finish()
	} catch (Exception e) {
		remapper.finish()
		throw new RuntimeException("Failed to remap jar", e)
	}
}


File getYoutubeApk(String ytVersion) {
	return file("youtube-${ytVersion}.apk")
}

File getYoutubeJar(String ytVersion) {
	return file("${cacheDir}/youtube-${ytVersion}.jar")
}

File getCleanedYoutubeJar(String ytVersion) {
	return file("${cacheDir}/youtube-${ytVersion}-cleaned.jar")
}

File getNamedYoutubeJar(String ytVersion) {
	return file("youtube-${ytVersion}-named.jar")
}

File getJadxProjectFile(String ytVersion) {
	return file("${jadxDir}/youtube-${ytVersion}.jadx")
}

File getIntermediaryFile(String ytVersion) {
	return file("${intermediaryDir}/${ytVersion}.tiny")
}

File getMatchFile(String ytVersionA, String ytVersionB) {
	return file("${matchesDir}/${ytVersionA} - ${ytVersionB}.match")
}



// **************************
//      Constants (2)
// **************************

def youtubeApk = getYoutubeApk(youtubeVersion)
def youtubeJar = getYoutubeJar(youtubeVersion)
def youtubeJarCleaned = getCleanedYoutubeJar(youtubeVersion)
def youtubeJarNamed = getNamedYoutubeJar(youtubeVersion)
def jadxProjectFile = getJadxProjectFile(youtubeVersion)
def intermediaryFile = getIntermediaryFile(youtubeVersion)



// **************************
//          Setup
// **************************

clean.doFirst {
	delete tempDir, cacheDir, jadxDir
}


task validateApkChecksum {
	doLast {
		logger.lifecycle(":validating youtube apk checksum")

		if (isChecksumValid(youtubeApk, youtubeApkChecksum) == false) {
			throw new RuntimeException("APK checksum doesn't match!")
		}
	}
}


import com.googlecode.d2j.dex.Dex2jar

task convertApkToJar(dependsOn: validateApkChecksum, type: FileIO) {
	group = setupGroup
	input = youtubeApk
	output = youtubeJar
	enabled = !youtubeJar.exists() || youtubeJar.length() < 30000000

	doLast {
		logger.lifecycle(":deleting old cache")
		delete cacheDir

		logger.lifecycle(":converting youtube apk to jar")

		Dex2jar d2j = Dex2jar.from(youtubeApk)
		d2j.to(youtubeJar.toPath())
		d2j.resetRandom()
	}
}

task copyYoutubeJarForCleanup(dependsOn: convertApkToJar, type: FileIO) {
	input youtubeJar
	output youtubeJarCleaned
	enabled = !youtubeJarCleaned.exists() || youtubeJarCleaned.length() < 30000000

	doLast {
		logger.lifecycle(":copying youtube jar for cleanup")
		copy {
			from youtubeJar
			into cacheDir
			rename { String fileName ->
				fileName.replace(youtubeJar.getName(), youtubeJarCleaned.getName())
			}
		}
	}
}


task removeUnneededPackagesFromJar(dependsOn: copyYoutubeJarForCleanup, type: FileIO) {
	group = setupGroup
	input = youtubeJarCleaned
	output = youtubeJarCleaned

	doLast {
		logger.lifecycle(":removing unneeded packages from jar")
		removeEntriesFromZip(youtubeJarCleaned.toPath(), 'J', 'j$')
	}
}


task checkMappings(dependsOn: removeUnneededPackagesFromJar) {
	group = buildMappingGroup
	inputs.dir mappingsDir

	doLast {
		logger.lifecycle(":checking mappings")

		String[] args = [
				youtubeJarCleaned.getAbsolutePath(),
				mappingsDir.getAbsolutePath()
		]

		try {
			// TODO: Re-enable when package-modifying mappings are supported
			// new CheckMappingsCommand().run(args)
		} catch (IllegalStateException ignored) {
			// just print, don't fail the task
		}
	}
}



// **************************
//      Export mappings
// **************************

task buildTinyMappingFiles(type: TinyMappingsOutput) {
	group = buildMappingGroup
	inputs.dir mappingsDir

	tiny1Output = file("yt-mappings-${mappingsVersion}.tiny")
	tiny2Output = file("yt-mappings-${mappingsVersion}-v2.tiny")

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":generating tiny mappings")

		new ConvertMappingsCommand().run(
			"enigma",
			mappingsDir.getAbsolutePath(),
			"tinyv2:official:named",
			tiny2Output.getAbsolutePath()
		)

		new ConvertMappingsCommand().run(
			"tinyv2",
			tiny2Output.getAbsolutePath(),
			"tiny:official:named",
			tiny1Output.getAbsolutePath())
	}
}


task buildNamedJar(dependsOn: [buildTinyMappingFiles, convertApkToJar]) {
	group = mapJarGroup
	inputs.file youtubeJar
	outputs.file youtubeJarNamed

	// Force the task to always run
	outputs.upToDateWhen { false }

	def jsrToJetbrains = [
		"javax/annotation/Nullable": "org/jetbrains/annotations/Nullable",
		"javax/annotation/Nonnull": "org/jetbrains/annotations/NotNull",
		"javax/annotation/concurrent/Immutable": "org/jetbrains/annotations/Unmodifiable"
	]

	doLast {
		logger.lifecycle(":mapping youtube jar to named")

		mapJar(youtubeJarNamed, youtubeJar, buildTinyMappingFiles.tiny2Output, null, "official", "named") {
			it.withMappings { out ->
				jsrToJetbrains.each { e ->
					out.acceptClass e.key, e.value
				}
			}
		}
	}
}



// **************************
//         Javadoc
// **************************

task genFakeSource(dependsOn: [buildTinyMappingFiles, buildNamedJar], type: JavaExec) {
	group = "javadoc generation"
	outputs.upToDateWhen { false }

	mainClass = "net.fabricmc.mappingpoet.Main"
	classpath configurations.mappingPoet
	// use merged v2 so we have all namespaces in jd
	args buildTinyMappingFiles.tiny2Output.getAbsolutePath(), youtubeJarNamed.getAbsolutePath(), fakeSourceDir.getAbsolutePath(), youtubeJar.getAbsolutePath()

	doLast {
		logger.lifecycle ":Fake source generated"
	}
}


javadoc {
	dependsOn genFakeSource
	dependsOn buildNamedJar
	group = "javadoc generation"
	outputs.upToDateWhen { false }

	def mappingPoetJar = project.provider { zipTree configurations.mappingPoetJar.singleFile }

	failOnError = false
	maxMemory = '2G'

	// verbose = true // enable to debug
	options {
		// verbose() // enable to debug
		source = "17"
		encoding = 'UTF-8'
		charSet = 'UTF-8'
		memberLevel = JavadocMemberLevel.PRIVATE
		splitIndex true
		tags(
				'apiNote:a:API Note:',
				'implSpec:a:Implementation Requirements:',
				'implNote:a:Implementation Note:'
		)
		taglets "net.fabricmc.mappingpoet.jd.MappingTaglet"
		// taglet path, header, extra stylesheet settings deferred
		it.use()

		addBooleanOption "-allow-script-in-comments", true
		addBooleanOption "-ignore-source-errors", true
		links(
				'https://guava.dev/releases/21.0/api/docs/',
				'https://www.javadoc.io/doc/com.google.code.gson/gson/2.8.0/',
				'https://logging.apache.org/log4j/2.x/log4j-api/apidocs/',
				"https://javadoc.io/doc/org.jetbrains/annotations/${project.jetbrains_annotations_version}/",
				'https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.2/',
				'https://javadoc.lwjgl.org/',
				'https://fastutil.di.unimi.it/docs/',
				'https://netty.io/4.1/api/',
				'https://commons.apache.org/proper/commons-logging/javadocs/api-1.1.3/',
				'https://commons.apache.org/proper/commons-lang/javadocs/api-3.5',
				'https://commons.apache.org/proper/commons-io/javadocs/api-2.5',
				'https://commons.apache.org/proper/commons-codec/archives/1.10/apidocs',
				'https://commons.apache.org/proper/commons-compress/javadocs/api-1.8.1/',
				"https://docs.oracle.com/en/java/javase/17/docs/api/"
		)
		// https://docs.oracle.com/en/java/javase/17/docs/specs/man/javadoc.html#additional-options-provided-by-the-standard-doclet
		addBooleanOption 'Xdoclint:html', true
		addBooleanOption 'Xdoclint:syntax', true
		addBooleanOption 'Xdoclint:reference', true
		addBooleanOption 'Xdoclint:accessibility', true
	}
	source fileTree(fakeSourceDir) + sourceSets.constants.allJava + sourceSets.packageDocs.allJava
	classpath = configurations.javadocClasspath.plus removeUnneededPackagesFromJar.outputs.files.asFileTree

	doLast {
		project.copy {
			from mappingPoetJar
			include "copy_on_click.js"
			into javadoc.outputDirectory
		}
	}

	doFirst {
		// lazy setting
		options {
			tagletPath configurations.mappingPoet.files.toList()
			header mappingPoetJar.get().filter { it.name == 'javadoc_header.txt' }.singleFile.text.trim() // cannot include line breaks
			addFileOption "-add-stylesheet", mappingPoetJar.get().filter { it.name == 'forms.css' }.singleFile
		}
	}
}


task javadocJar(dependsOn: javadoc, type: Jar) {
	group = "javadoc generation"

	from javadoc.destinationDir

	archiveVersion.set mappingsVersion
	archiveClassifier = 'javadoc'
}


javadocLint {
	group = "javadoc generation"
	mappingDirectory = file("mappings")
}
check.dependsOn javadocLint



// **************************
//   External applications
// **************************

import net.fabricmc.mappingio.MappingReader;
import net.fabricmc.mappingio.MappingWriter;
import net.fabricmc.mappingio.format.MappingFormat;
import net.fabricmc.mappingio.tree.MemoryMappingTree;

task mergeDuplicateMappings(dependsOn: checkMappings) {
	group = mappingsGroup

	doLast {
		logger.lifecycle(":merging duplicate mapping files")

		MemoryMappingTree tree = new MemoryMappingTree();
		MappingReader.read(mappingsDir.toPath(), tree);
		tree.accept(MappingWriter.create(mappingsDir.toPath(), MappingFormat.ENIGMA));
	}
}

task enigma(dependsOn: checkMappings, type: JavaExec) {
	group = mappingsGroup

	classpath = configurations.enigmaClasspath
	mainClass = 'cuchaz.enigma.gui.Main'

	args '-jar'
	args youtubeJarCleaned.getAbsolutePath()
	args '-mappings'
	args mappingsDir.getAbsolutePath()
	args '-profile'
	args 'enigma_profile.json'

	jvmArgs project.enigma_jvmargs
}


task prepareJadx {
	enabled = !jadxProjectFile.exists()

	doLast {
		jadxDir.mkdirs()
		jadxProjectFile.text = """
			{
				"projectVersion": 1,
				"files": [
					"../youtube-${youtubeVersion}.apk"
				],
				"cacheDir": "youtube-${youtubeVersion}.apk.cache"
			}
		"""
	}
}


task jadx(dependsOn: [validateApkChecksum, prepareJadx], type: JavaExec) {
	group = mappingsGroup

	classpath = configurations.jadxClasspath
	mainClass = 'jadx.gui.JadxGUI'

	args jadxProjectFile.getAbsolutePath()
	args '--mappings-path'
	args mappingsDir.getAbsolutePath()

	jvmArgs project.jadx_jvmargs
}


task validateNewVersionProp {
	if (!project.hasProperty('newYtVersion')) {
		// Use a dummy version during project evaluation,
		// otherwise tasks like `clean` would crash.
		project.ext.newYtVersion = '0.0.0'

		doLast {
			throw new RuntimeException("Property \"newYtVersion\" hasn't been set! Pass it via \"-P'newYtVersion'='<version>'\".")
		}
	} else if (newYtVersion == youtubeVersion) {
		throw new IllegalArgumentException("New version equals old version!")
	} else if (!getYoutubeApk(newYtVersion).exists()) {
		throw new IllegalArgumentException("Couldn't find an APK with the specified version!")
	}
}


task prepareJadxForNewYtVersion(dependsOn: validateNewVersionProp) {
	def newJadxProjectFile = getJadxProjectFile(newYtVersion)
	enabled = !newJadxProjectFile.exists()

	doLast {
		jadxDir.mkdirs()
		newJadxProjectFile.text = """
			{
				"projectVersion": 1,
				"files": [
					"../youtube-${newYtVersion}.apk"
				],
				"cacheDir": "youtube-${newYtVersion}.apk.cache"
			}
		"""
	}
}


task jadxNewYtVersion(dependsOn: [validateApkChecksum, prepareJadxForNewYtVersion], type: JavaExec) {
	group = mappingsGroup

	classpath = configurations.jadxClasspath
	mainClass = 'jadx.gui.JadxGUI'

	args getJadxProjectFile(newYtVersion).getAbsolutePath()
	jvmArgs project.jadx_jvmargs
}


task convertApkToMatchAgainstToJar(dependsOn: validateNewVersionProp, type: FileIO) {
	def youtubeApkToMatchAgainst = getYoutubeApk(newYtVersion)
	def youtubeJarToMatchAgainst = getYoutubeJar(newYtVersion)

	group = setupGroup
	input = youtubeApkToMatchAgainst
	output = youtubeJarToMatchAgainst
	enabled = !youtubeJarToMatchAgainst.exists() || youtubeJarToMatchAgainst.length() < 30000000

	doLast {
		logger.lifecycle(":converting new youtube version apk to jar")

		Dex2jar d2j = Dex2jar.from(youtubeApkToMatchAgainst)
		d2j.to(youtubeJarToMatchAgainst.toPath())
		d2j.resetRandom()
	}
}


task matcher(dependsOn: [convertApkToJar, convertApkToMatchAgainstToJar], type: JavaExec) {
	group = mappingsGroup

	classpath = configurations.matcherClasspath
	mainClass = "matcher.Main"

	args '--inputs-a'
	args youtubeJar.getAbsolutePath()

	args '--inputs-b'
	args getYoutubeJar(newYtVersion).getAbsolutePath()

	// Disabled due to random minified packages like in com/google/android/apps/youtube/embeddedplayer/service/
	// args '--non-obfuscated-class-pattern-a'
	// args '^.*/.*$'
	// args '--non-obfuscated-class-pattern-b'
	// args '^.*/.*$'

	args '--mappings-a'
	args mappingsDir.getAbsolutePath()

	args '--hide-unmapped-a'
	// args '--dont-save-unmapped-matches'

	jvmArgs project.matcher_jvmargs
}

task generateGitRepo(type: JavaExec) {
	classpath = configurations.gitifierClasspath
	mainClass = 'ytre.gitifier.Main'

	args 'generateRepo'
	args './'
	args intermediaryDir
	args './git-repo'
	args '--overwrite'

	jvmArgs project.gitifier_jvmargs
}



// **************************
//       Intermediary
// **************************

task copyYoutubeJarToMatchAgainstForCleanup(dependsOn: convertApkToMatchAgainstToJar) {
	def youtubeJarToMatchAgainst = getYoutubeJar(newYtVersion)
	def youtubeJarToMatchAgainstCleaned = getCleanedYoutubeJar(newYtVersion)
	enabled = !youtubeJarToMatchAgainstCleaned.exists() || youtubeJarToMatchAgainstCleaned.length() < 30000000

	doLast {
		logger.lifecycle(":copying new youtube jar for cleanup")
		copy {
			from youtubeJarToMatchAgainst
			into cacheDir
			rename { String fileName ->
				fileName.replace(youtubeJarToMatchAgainst.getName(), youtubeJarToMatchAgainstCleaned.getName())
			}
		}
	}
}


task removeUnneededPackagesFromJarToMatchAgainst(dependsOn: copyYoutubeJarToMatchAgainstForCleanup, type: FileIO) {
	group = setupGroup

	def youtubeJarToMatchAgainstCleaned = getCleanedYoutubeJar(newYtVersion)
	input = youtubeJarToMatchAgainstCleaned
	output = youtubeJarToMatchAgainstCleaned

	doLast {
		logger.lifecycle(":removing unneeded packages from new jar")
		removeEntriesFromZip(youtubeJarToMatchAgainstCleaned.toPath(), 'J', 'j$')
	}
}


task generateIntermediary(dependsOn: removeUnneededPackagesFromJar, type: JavaExec) {
	group = mappingsGroup
	enabled = !intermediaryFile.exists()

	classpath = configurations.stitchClasspath
	mainClass = 'net.fabricmc.stitch.Main'

	systemProperty 'stitch.counter', intermediaryCounter.toPath()
	args 'generateIntermediary'
	args youtubeJarCleaned.getAbsolutePath()
	args intermediaryFile

	jvmArgs project.stitch_jvmargs
}


task updateIntermediary(dependsOn: [generateIntermediary, removeUnneededPackagesFromJarToMatchAgainst], type: JavaExec) {
	def newIntermediaryFile = getIntermediaryFile(newYtVersion)

	group = mappingsGroup
	enabled = !newIntermediaryFile.exists()

	classpath = configurations.stitchClasspath
	mainClass = 'net.fabricmc.stitch.Main'

	systemProperty 'stitch.counter', intermediaryCounter.toPath()
	args 'updateIntermediary'
	args youtubeJarCleaned.getAbsolutePath()
	args getCleanedYoutubeJar(newYtVersion).getAbsolutePath()
	args intermediaryFile
	args newIntermediaryFile
	args getMatchFile(youtubeVersion, newYtVersion)

	jvmArgs project.stitch_jvmargs
}
