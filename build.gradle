// **************************
//       Gradle setup
// **************************

buildscript {
	repositories {
		maven {
			name "Fabric Repository"
			url 'https://maven.fabricmc.net'
		}
		maven {
			name "JitPack"
			url 'https://jitpack.io'
		}
		mavenCentral()
		mavenLocal()
	}
	dependencies {
		classpath "cuchaz:enigma-cli:${project.enigma_version}"
		classpath "commons-io:commons-io:2.11.0"
		classpath "net.fabricmc:mapping-io:${project.mappingio_version}"
		classpath "net.fabricmc:tiny-remapper:${project.tiny_remapper_version}"
		classpath "net.fabricmc:name-proposal:${project.name_proposal_version}"
		classpath "com.github.ThexXTURBOXx:dex2jar:v${project.dex2jar_version}"
	}
}

plugins {
	id 'java' // for constants, packages, javadoc
	id 'maven-publish'
	id "com.diffplug.spotless" version "6.4.2"
	id 'net.fabricmc.filament' version '0.3.0'
}

repositories {
	mavenCentral()
	maven {
		name "Fabric Repository"
		url 'https://maven.fabricmc.net'
	}
	maven {
		name "JitPack"
		url 'https://jitpack.io'
	}
	maven {
		name "Quilt"
		url 'https://maven.quiltmc.org/repository/release/'
	}
	google()
	mavenLocal()
}

configurations {
	asm
	enigmaRuntime {
		extendsFrom asm
	}
	jadxRuntime
	matcherClasspath
	javadocClasspath
	mappingPoetJar {
		transitive = false
	}
	mappingPoet {
		extendsFrom mappingPoetJar
		extendsFrom asm
		transitive = true
	}
}

dependencies {
	enigmaRuntime "cuchaz:enigma-swing:${project.enigma_version}"
	enigmaRuntime "net.fabricmc:name-proposal:${project.name_proposal_version}"
	enigmaRuntime project(':enigma-plugin')
	// TODO: Switch to Maven Central package (https://github.com/skylot/jadx/issues/1579)
	jadxRuntime ("com.github.NebelNidas.jadx:jadx-gui:${project.jadx_version}:all") {
		transitive = false
	}
	matcherClasspath "com.github.NebelNidas:Matcher:${project.matcher_version}:all"
	javadocClasspath "org.jetbrains:annotations:${project.jetbrains_annotations_version}"
	javadocClasspath "com.google.code.findbugs:jsr305:3.0.2" // for some other jsr annotations
	mappingPoetJar "net.fabricmc:mappingpoet:${project.mappingpoet_version}"
	asm "org.ow2.asm:asm:${project.asm_version}"
	asm "org.ow2.asm:asm-tree:${project.asm_version}"
	asm "org.ow2.asm:asm-commons:${project.asm_version}"
	asm "org.ow2.asm:asm-util:${project.asm_version}"
}

sourceCompatibility = JavaVersion.VERSION_17
targetCompatibility = JavaVersion.VERSION_17

tasks.withType(JavaCompile).configureEach {
	it.options.encoding = "UTF-8"
	it.options.release = 17
}

sourceSets {
	constants
	packageDocs // package info files
}

spotless {
	java {
		licenseHeaderFile(rootProject.file("HEADER"))
	}
}



// **************************
//        Variables
// **************************

def youtubeVersion = project.youtube_version
def youtubeApkChecksum = project.youtube_apk_md5

def ENV = System.getenv()
// Fetch build number from Github Actions
def buildNumber = ENV.BUILD_NUMBER ?: "local"

def mappingsVersion = "${youtubeVersion}+build.$buildNumber"
version = mappingsVersion

def setupGroup = "jar setup"
def mappingsGroup = "yt-mappings"
def buildMappingGroup = "mapping build"
def mapJarGroup = "jar mapping"

def mappingsDir = file("mappings")
def cacheDir = file(".gradle/youtube")
def tempDir = file(".gradle/temp")
def fakeSourceDir = file(".gradle/temp/fakeSource")

def youtubeApk = file("youtube.apk")
def youtubeJar = file("${cacheDir}/youtube-${youtubeVersion}.jar")
def youtubeJarCleaned = file("${cacheDir}/youtube-${youtubeVersion}-cleaned.jar")
def youtubeJarNamed = file("youtube-${youtubeVersion}-named.jar")
def jadxProjectFile = file(".jadx/youtube-${youtubeVersion}.jadx")
def youtubeApkToMatchAgainst = file("youtube-new.apk")
def youtubeJarToMatchAgainst = file("${cacheDir}/youtube-new.jar")



// **************************
//         Classes
// **************************

class FileOutput extends DefaultTask {
	@OutputFile
	File output
}

class FileOutputInput extends DefaultTask {
	@InputFile
	File input
	@OutputFile
	File output
}

class WithV2FileOutput extends DefaultTask {
	@OutputFile
	File tiny1Output
	@OutputFile
	File tiny2Output
}



// **************************
//        File utils
// **************************

import com.google.common.hash.Hashing
import cuchaz.enigma.command.CheckMappingsCommand
import cuchaz.enigma.command.ConvertMappingsCommand
import groovy.io.FileType
import groovy.json.JsonSlurper
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import net.fabricmc.tinyremapper.TinyUtils

import java.nio.charset.StandardCharsets
import java.util.zip.GZIPOutputStream

boolean isChecksumValid(File file, String checksum) {
	if (file != null) {
		def hash = com.google.common.io.Files.asByteSource(file).hash(Hashing.md5())
		return hash.toString().equals(checksum)
	}
	return false
}


import java.io.File
import java.net.URI;
import java.nio.file.DirectoryStream;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.LinkOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.ZipFile

void deleteDirectory(Path path) throws IOException {
	if (Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS)) {
		try (DirectoryStream<Path> entries = Files.newDirectoryStream(path)) {
			for (Path entry : entries) {
				deleteDirectory(entry);
			}
		}
	}
	Files.delete(path);
}


void mapJar(File output, File input, File mappings, File libraries, String from, String to,
		Action<TinyRemapper.Builder> action = { }) {
	if (output.exists()) {
		output.delete()
	}

	def remapperBuilder = TinyRemapper.newRemapper()
			.withMappings(TinyUtils.createTinyMappingProvider(mappings.toPath(), from, to))
			.renameInvalidLocals(true)
			.rebuildSourceFilenames(true)
			.invalidLvNamePattern(~/\$\$\d+/)
			.inferNameFromSameLvIndex(true)

	action.execute(remapperBuilder)
	def remapper = remapperBuilder
			.build()

	try {
		def outputConsumerBuilder = new OutputConsumerPath.Builder(output.toPath())
		// expose output consumer builder to function if there is need in the future
		def outputConsumer = outputConsumerBuilder.build()
		outputConsumer.addNonClassFiles(input.toPath())
		remapper.readInputs(input.toPath())

		// libraries.eachFileRecurse(FileType.FILES) { file ->
		// 	remapper.readClassPath(file.toPath())
		// }
		remapper.apply(outputConsumer)
		outputConsumer.close()
		remapper.finish()
	} catch (Exception e) {
		remapper.finish()
		throw new RuntimeException("Failed to remap jar", e)
	}
}


clean.doFirst {
	delete tempDir, cacheDir, jadxProjectFile.getParentFile()
}



// **************************
//          Setup
// **************************

task validateApkChecksum {
	doLast {
		logger.lifecycle(":validating youtube apk checksum")

		if (isChecksumValid(youtubeApk, youtubeApkChecksum) == false) {
			throw new RuntimeException("APK checksum doesn't match!")
		}
	}
}


import com.googlecode.d2j.dex.Dex2jar

task convertApkToJar(dependsOn: validateApkChecksum, type: FileOutputInput) {
	group = setupGroup
	input youtubeApk
	output youtubeJar

	doLast {
		logger.lifecycle(":deleting old cache")
		delete cacheDir

		logger.lifecycle(":converting youtube apk to jar")

		Dex2jar d2j = Dex2jar.from(youtubeApk)
		d2j.to(youtubeJar.toPath())
		d2j.resetRandom()
	}
}
convertApkToJar.enabled = !youtubeJar.exists() || youtubeJar.length() < 30000000


task copyYoutubeJarForCleanup(dependsOn: convertApkToJar) {
	doLast {
		logger.lifecycle(":copying youtube jar for cleanup")
		copy {
			from youtubeJar
			into cacheDir
			rename { String fileName ->
				fileName.replace(youtubeJar.getName(), youtubeJarCleaned.getName())
			}

		}

	}
}
copyYoutubeJarForCleanup.enabled = !youtubeJarCleaned.exists() || youtubeJarCleaned.length() < 30000000


import java.nio.file.NoSuchFileException

task removeUnneededPackagesFromJar(dependsOn: copyYoutubeJarForCleanup, type: FileOutputInput) {
	group = setupGroup
	input youtubeJarCleaned
	output youtubeJarCleaned

	doLast {
		logger.lifecycle(":removing unneeded packages from jar")

		List<String> packagesToDelete = Arrays.asList(
			// 'android',
			// 'androidx',
			// 'com',
			// 'dagger',
			// 'io',
			// 'J',
			'j$',			// The dollar sign causes some issues with certain tools
			// 'kotlinx',
			// 'org'
		);

		/* Define ZIP File System Properies in HashMap */
		Map<String, String> zipProperties = new HashMap<>();
		/* We want to read an existing ZIP File, so we set this to False */
		zipProperties.put("create", "false");

		Path path = youtubeJarCleaned.toPath();
		URI zipFile = URI.create("jar:" + path.toUri());

		/* Create ZIP file System */
		try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, zipProperties)) {
			for (String pack : packagesToDelete) {
				Path pathInZipfile = zipfs.getPath(pack);
				deleteDirectory(pathInZipfile);
			}
		} catch (NoSuchFileException e) {}
	}
}


task checkMappings(dependsOn: removeUnneededPackagesFromJar) {
	group = buildMappingGroup
	inputs.dir mappingsDir

	doLast {
		logger.lifecycle(":checking mappings")

		String[] args = [
				youtubeJarCleaned.getAbsolutePath(),
				mappingsDir.getAbsolutePath()
		]

		try {
			// TODO: Re-enable when package-modifying mappings are supported
			// new CheckMappingsCommand().run(args)
		} catch (IllegalStateException ignored) {
			// just print, don't fail the task
		}
	}
}



// **************************
//      Export mappings
// **************************

task buildTinyMappingFiles(type: WithV2FileOutput) {
	group = buildMappingGroup
	inputs.dir mappingsDir

	tiny1Output = file("yt-mappings-${mappingsVersion}.tiny")
	tiny2Output = file("yt-mappings-${mappingsVersion}-v2.tiny")

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":generating tiny mappings")

		new ConvertMappingsCommand().run(
			"enigma",
			mappingsDir.getAbsolutePath(),
			"tinyv2:official:named",
			tiny2Output.getAbsolutePath()
		)

		new ConvertMappingsCommand().run(
			"tinyv2",
			tiny2Output.getAbsolutePath(),
			"tiny:official:named",
			tiny1Output.getAbsolutePath())
	}
}


task buildNamedJar(dependsOn: [buildTinyMappingFiles, convertApkToJar]) {
	group = mapJarGroup
	inputs.file youtubeJar
	outputs.file youtubeJarNamed

	//Force the task to always run
	outputs.upToDateWhen { false }

	def jsrToJetbrains = [
		"javax/annotation/Nullable": "org/jetbrains/annotations/Nullable",
		"javax/annotation/Nonnull": "org/jetbrains/annotations/NotNull",
		"javax/annotation/concurrent/Immutable": "org/jetbrains/annotations/Unmodifiable"
	]

	doLast {
		logger.lifecycle(":mapping youtube jar to named")

		mapJar(youtubeJarNamed, youtubeJar, buildTinyMappingFiles.tiny2Output, null, "official", "named") {
			it.withMappings { out ->
				jsrToJetbrains.each { e ->
					out.acceptClass e.key, e.value
				}
			}
		}
	}
}



// **************************
//         Javadoc
// **************************

task genFakeSource(dependsOn: [buildTinyMappingFiles, buildNamedJar], type: JavaExec) {
	group = "javadoc generation"
	outputs.upToDateWhen { false }

	mainClass = "net.fabricmc.mappingpoet.Main"
	classpath configurations.mappingPoet
	// use merged v2 so we have all namespaces in jd
	args buildTinyMappingFiles.tiny2Output.getAbsolutePath(), youtubeJarNamed.getAbsolutePath(), fakeSourceDir.getAbsolutePath(), youtubeJar.getAbsolutePath()

	doLast {
		logger.lifecycle ":Fake source generated"
	}
}


javadoc {
	dependsOn genFakeSource
	dependsOn buildNamedJar
	group = "javadoc generation"
	outputs.upToDateWhen { false }

	def mappingPoetJar = project.provider { zipTree configurations.mappingPoetJar.singleFile }

	failOnError = false
	maxMemory = '2G'

	// verbose = true // enable to debug
	options {
		// verbose() // enable to debug
		source = "17"
		encoding = 'UTF-8'
		charSet = 'UTF-8'
		memberLevel = JavadocMemberLevel.PRIVATE
		splitIndex true
		tags(
				'apiNote:a:API Note:',
				'implSpec:a:Implementation Requirements:',
				'implNote:a:Implementation Note:'
		)
		taglets "net.fabricmc.mappingpoet.jd.MappingTaglet"
		// taglet path, header, extra stylesheet settings deferred
		it.use()

		addBooleanOption "-allow-script-in-comments", true
		addBooleanOption "-ignore-source-errors", true
		links(
				'https://guava.dev/releases/21.0/api/docs/',
				'https://www.javadoc.io/doc/com.google.code.gson/gson/2.8.0/',
				'https://logging.apache.org/log4j/2.x/log4j-api/apidocs/',
				"https://javadoc.io/doc/org.jetbrains/annotations/${project.jetbrains_annotations_version}/",
				'https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.2/',
				'https://javadoc.lwjgl.org/',
				'https://fastutil.di.unimi.it/docs/',
				'https://netty.io/4.1/api/',
				'https://commons.apache.org/proper/commons-logging/javadocs/api-1.1.3/',
				'https://commons.apache.org/proper/commons-lang/javadocs/api-3.5',
				'https://commons.apache.org/proper/commons-io/javadocs/api-2.5',
				'https://commons.apache.org/proper/commons-codec/archives/1.10/apidocs',
				'https://commons.apache.org/proper/commons-compress/javadocs/api-1.8.1/',
				"https://docs.oracle.com/en/java/javase/17/docs/api/"
		)
		// https://docs.oracle.com/en/java/javase/17/docs/specs/man/javadoc.html#additional-options-provided-by-the-standard-doclet
		addBooleanOption 'Xdoclint:html', true
		addBooleanOption 'Xdoclint:syntax', true
		addBooleanOption 'Xdoclint:reference', true
		addBooleanOption 'Xdoclint:accessibility', true
	}
	source fileTree(fakeSourceDir) + sourceSets.constants.allJava + sourceSets.packageDocs.allJava
	classpath = configurations.javadocClasspath.plus removeUnneededPackagesFromJar.outputs.files.asFileTree

	doLast {
		project.copy {
			from mappingPoetJar
			include "copy_on_click.js"
			into javadoc.outputDirectory
		}
	}

	doFirst {
		// lazy setting
		options {
			tagletPath configurations.mappingPoet.files.toList()
			header mappingPoetJar.get().filter { it.name == 'javadoc_header.txt' }.singleFile.text.trim() // cannot include line breaks
			addFileOption "-add-stylesheet", mappingPoetJar.get().filter { it.name == 'forms.css' }.singleFile
		}
	}
}


task javadocJar(dependsOn: javadoc, type: Jar) {
	group = "javadoc generation"

	from javadoc.destinationDir

	archiveVersion.set mappingsVersion
	archiveClassifier = 'javadoc'
}


javadocLint {
	group = "javadoc generation"
	mappingDirectory = file("mappings")
}
check.dependsOn javadocLint



// **************************
//   External applications
// **************************

task enigma(dependsOn: checkMappings, type: JavaExec) {
	group = mappingsGroup

	classpath = configurations.enigmaRuntime
	mainClass = 'cuchaz.enigma.gui.Main'

	args '-jar'
	args youtubeJarCleaned.getAbsolutePath()
	args '-mappings'
	args mappingsDir.getAbsolutePath()
	args '-profile'
	args 'enigma_profile.json'

	jvmArgs project.enigma_jvmargs
}


task prepareJadx {
	doLast {
		jadxProjectFile.getParentFile().mkdirs()
		jadxProjectFile.text = """
			{
				"projectVersion": 1,
				"files": [
					"../youtube.apk"
				],
				"cacheDir": "youtube-${youtubeVersion}.apk.cache"
			}
		"""
	}
}
prepareJadx.enabled = !jadxProjectFile.exists()


task jadx(dependsOn: [validateApkChecksum, prepareJadx], type: JavaExec) {
	group = mappingsGroup

	classpath = configurations.jadxRuntime
	mainClass = 'jadx.gui.JadxGUI'

	args jadxProjectFile.getAbsolutePath()
	args '--mappings-path'
	args mappingsDir.getAbsolutePath()
	// args '--mappings-mode'
	// args 'read_and_autosave_every_change'
	// args 'read_and_autosave_before_closing'

	jvmArgs project.jadx_jvmargs
}


task convertApkToMatchAgainstToJar(type: FileOutputInput) {
	group = setupGroup
	input youtubeApkToMatchAgainst
	output youtubeJarToMatchAgainst

	doLast {
		logger.lifecycle(":converting new youtube version apk to jar")

		Dex2jar d2j = Dex2jar.from(youtubeApkToMatchAgainst)
		d2j.to(youtubeJarToMatchAgainst.toPath())
		d2j.resetRandom()
	}
}
convertApkToMatchAgainstToJar.enabled = !youtubeJarToMatchAgainst.exists() || youtubeJarToMatchAgainst.length() < 30000000


task matcher(dependsOn: [convertApkToJar, convertApkToMatchAgainstToJar], type: JavaExec) {
	group = mappingsGroup

	classpath = configurations.matcherClasspath
	mainClass = "matcher.Main"

	args '--inputs-a'
	args youtubeJar.getAbsolutePath()

	args '--inputs-b'
	args youtubeJarToMatchAgainst.getAbsolutePath()

	args '--mappings-a'
	args mappingsDir.getAbsolutePath()

	args '--hide-unmapped-a'
	// args '--dont-save-unmapped-matches'

	jvmArgs project.matcher_jvmargs
}
